/*
문제38 : 호준이의 아르바이트

호준이는 아르바이트로 영어 학원에서 단어 시험지를 채점하는 일을 하고 있다. 호준이가 일하는 학원은 매번 1위부터 3위까지의 학생에게 상으로 사탕을 준다.
그런데 오늘은 마침 사탕이 다 떨어져서 호준이가 채점을 하고 점수를 보내면, 당신이 아이들의 숫자만큼 사탕을 사러 가기로 했다.

1위 ~ 3위 학생은 여러명일 수 있고 1~3위 학생 중 중복되는 학생까지 포함하여 사탕을 사기로 한다.
학생들의 점수를 공백으로 구분하여 입력을 받고 사탕을 받을 학생의 수를 출력하세요.

입출력

입력 : 97 86 75 66 55 97 85 97 97 95
출력 : 6

*/

// 1.
const solution = (input) => {
  // 먼저 input 값의 공백을 split 해주고 map 함수를 활용하여 배열의 모든 요소를 parseInt 해준다.
  const scores = input.split(" ").map((x) => {
    return parseInt(x, 10);
  });

  // sort 함수로 배열을 정렬해준다. a - b 하면, 오름차순으로 정렬할 수 있다.
  scores.sort((a, b) => {
    return a - b;
  });

  // 임의의 변수 count와 winnerArr라는 빈 배열을 만든다.
  // count는 사탕을 받을 학생 수를 세기위해 사용할 것이며,
  // rankArr의 배연에 1, 2, 3등의 점수를 저장할 것이다.
  let count = 0;
  let rankArr = [];

  // 반복이 시작되기 전에 조건문은 참,거짓을 판단받게 된다.
  // 만약 조건문이 참이라면, while문 안의 문장들이 실행된다.
  // 거짓이라면, 문장은 그냥 while 반복문 후로 넘어간다.
  while (rankArr.length < 3) {
    // rankArr의 길이가 3이 된다는 것은 1, 2, 3등의 점수가 모두 저장되었을 때를 의미한다.
    // 때문에 3등이 선정되기 전까지 반복을 실행하는 것이다.

    let number = scores.pop();
    // pop은 배열의 마지막 요소를 제거하고 반환하는 함수다.
    if (!rankArr.includes(number)) {
      // 최초 rankArr에서 number요소가 포함되었는지 판별한다.
      rankArr.push(number); // 조건을 통과하면 rankArr에 저장한다.
      // 반대로 통과하지 못하면 그냥 지나친다.
    }
    count += 1; // rankArr의 길이가 3미만인 한, 반복문이 실행될 때마다 count 변수의 값이 1만큼 증가할 것이다.
  }

  console.log(rankArr, "rankArr");
  // 해당 반복문이 종료되는 시점에서 rankArr의 값을 console로 출력해보면 [97, 95, 85]가 나올 것이다.
  // 이 의미는 곧 1, 2, 3등의 점수가 확정되었다는 의미와 같다.

  return console.log(count);
  // rankArr의 값이 3이 되는 순간 count를 출력하면, 1등 부터 3등까지 점수를 부여받은 학생의 숫자를 알 수 있다.
};

solution("97 86 75 66 55 97 85 97 97 95");
